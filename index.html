
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Salesbuildr Widget Template Tools</title>
    
    <!-- External Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <!-- Inline Styles -->
    <style>
        /* Global Styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1, h2 {
            color: #2c3e50;
        }
        
        /* Tab Navigation */
        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        
.tab-button {
    padding: 10px 20px;
    background-color: #e0e0e0; /* Darker gray for inactive tabs */
    border: 1px solid #ddd;
    border-bottom: none;
    border-radius: 4px 4px 0 0;
    margin-right: 5px;
    cursor: pointer;
    transition: background-color 0.3s;
    color: #333; /* Dark text for better contrast on inactive tabs */
}

.tab-button:hover {
    background-color: #d0d0d0; /* Even darker on hover */
}

.tab-button.active {
    background-color: #2980b9; /* Keep the blue for active tab */
    color: white; /* White text for active tab */
    border-color: #2980b9;
}
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Container Layout */
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        /* Dropzone Styles */
        .dropzone {
            border: 3px dashed #ccc;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            background-color: #f9f9f9;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .dropzone:hover, .dropzone.dragover {
            border-color: #3498db;
            background-color: #ecf0f1;
        }
        
        /* Options Panel */
        .options {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
            padding: 20px;
            background-color: #f5f5f5;
            border-radius: 8px;
        }
        
        .option-group {
            display: flex;
            flex-direction: column;
            min-width: 200px;
        }
        
        label {
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        input, select, textarea {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        /* Buttons */
        .button-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            background-color: #2980b9;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover:not(:disabled) {
            background-color: #3498db;
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        /* Progress Indicator */
        .progress-container {
            margin: 20px 0;
            display: none;
        }
        
        progress {
            width: 100%;
            height: 20px;
        }
        
        /* Preview Grid */
        .preview-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .preview-item {
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #ddd;
        }
        
        .preview-title {
            font-weight: 600;
            margin: 0;
        }
        
        .preview-image {
            display: block;
            width: 100%;
            height: auto;
            max-height: 400px;
            object-fit: contain;
            background-color: white;
            padding: 10px;
            box-sizing: border-box;
        }
        
        .preview-actions {
            padding: 10px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        /* Status Messages */
        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
        }
        
        .status.success {
            background-color: #d4edda;
            color: #155724;
        }
        
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        /* Log Container */
        .log-container {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 14px;
            margin-top: 20px;
        }
        
        .log-entry {
            margin: 0;
            padding: 2px 0;
        }
        
        .log-entry.error {
            color: #dc3545;
        }
        
        .log-entry.warn {
            color: #ffc107;
        }
        
        .log-entry.info {
            color: #17a2b8;
        }
        
        /* Download All Button */
        .download-all-button {
            display: block;
            margin: 20px auto;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #2980b9;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        /* Widget Creator Styles */
        .widget-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .url-container {
            display: flex;
            gap: 10px;
        }
        
        .url-input {
            flex-grow: 1;
        }
        
        .widget-options {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 10px;
        }
        
        .image-preview {
            max-width: 300px;
            max-height: 200px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            object-fit: contain;
        }
        
        .widget-preview {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            background-color: white;
        }
        
        .widget-preview table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .widget-preview td {
            padding: 10px;
            vertical-align: top;
        }
        
        .code-container {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            position: relative;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .code-content {
            max-height: 300px;
            overflow-y: auto;
            background-color: #fff;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .options, .widget-options {
                flex-direction: column;
            }
            
            .preview-container {
                grid-template-columns: 1fr;
            }
            
            .url-container {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <h1>Salesbuildr Widget Template Tools</h1>
    
    <!-- Tab Navigation -->
    <div class="tabs">
        <button class="tab-button active" data-tab="extractor">Cover Page Creator</button>
        <button class="tab-button" data-tab="widget">Widget Creator</button>
    </div>
    
    <!-- PDF Text Extractor Tab -->
    <div id="extractor" class="tab-content active">
        <p>Create Salesbuildr Cover Pages from PDF files.</p>
        
        <div class="container">
            <div id="dropzone" class="dropzone">
                <h2>Drag & Drop PDF Files Here</h2>
                <p>Or click to select files</p>
                <input type="file" id="file-input" style="display: none;" accept=".pdf" multiple>
            </div>
            
            <div class="options">
                <div class="option-group">
                    <label for="page-input">Page Numbers (comma-separated):</label>
                    <input type="text" id="page-input" placeholder="e.g., 1,2,5" value="1">
                    <small>Leave blank for all pages</small>
                </div>
                
                <div class="option-group">
                    <label for="dpi-input">DPI Resolution:</label>
                    <select id="dpi-input">
                        <option value="150">150 DPI (Fast)</option>
                        <option value="300" selected>300 DPI (Balanced)</option>
                        <option value="600">600 DPI (High Quality)</option>
                    </select>
                </div>
                
                <div class="option-group">
                    <label for="resize-input">Output Format:</label>
                    <select id="resize-input">
                        <option value="true" selected>Resize to A4</option>
                        <option value="false">Original Size</option>
                    </select>
                </div>
            </div>
            
            <div class="button-container">
                <button id="process-btn" disabled>Process PDFs</button>
                <button id="clear-btn">Clear Fields</button>
            </div>
            
            <div class="progress-container" id="progress-container">
                <p id="progress-text">Processing 0/0 files...</p>
                <progress id="progress-bar" value="0" max="100"></progress>
            </div>
            
            <div id="status" class="status" style="display: none;"></div>
            
            <div id="log-container" class="log-container">
                <p class="log-entry info">System ready. Upload PDF files to begin.</p>
            </div>
            
            <div id="preview-container" class="preview-container"></div>
        </div>
    </div>
    
    <!-- Widget Creator Tab -->
    <div id="widget" class="tab-content">
        <p>Create widgets using content from websites or biuild custom content. Paste HTML code into Salesbuildr. </p>
        
        <div class="container">
            <div class="widget-form">
                <div class="url-container">
                    <input type="url" id="website-url" class="url-input" placeholder="Enter website URL (e.g., https://example.com)">
                    <button id="fetch-btn">Fetch Content</button>
                </div>
                
                <div class="widget-options">
                    <div class="option-group">
                        <label for="image-position">Image Position:</label>
                        <select id="image-position">
                            <option value="left" selected>Left</option>
                            <option value="right">Right</option>
                        </select>
                    </div>
                    
                    <div class="option-group">
                        <label for="paragraph-count">Summary Length:</label>
                        <select id="paragraph-count">
                            <option value="1">1 Paragraph</option>
                            <option value="2" selected>2 Paragraphs</option>
                            <option value="3">3 Paragraphs</option>
                        </select>
                    </div>
                    
                    <div class="option-group">
                        <label for="custom-image">Custom Image (optional):</label>
                        <input type="file" id="custom-image" accept="image/*">
                    </div>
                </div>
                
                <div class="text-content">
                    <label for="summary-text">Summary Text (edit as needed):</label>
                    <textarea id="summary-text" rows="6" placeholder="Your content summary will appear here. You can edit it as needed." style="width: 100%;"></textarea>
                </div>
                
                <div class="button-container">
                    <button id="generate-widget-btn">Generate Widget</button>
                    <button id="clear-widget-btn">Clear All</button>
                </div>
                
                <div id="widget-status" class="status" style="display: none;"></div>
            </div>
            
            <div id="widget-preview-container" style="display: none;">
                <h3>Widget Preview</h3>
                <div class="widget-preview" id="widget-preview"></div>
                
                <div class="code-container">
                    <div class="code-header">
                        <h3>HTML Code</h3>
                        <button id="copy-code-btn">Copy Code</button>
                    </div>
                    <div class="code-content" id="widget-code"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Inline JavaScript -->
    <script>
        // Set up PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
        
        // Tab Switching
        document.addEventListener('DOMContentLoaded', () => {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all buttons and contents
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    
                    // Add active class to current button and corresponding content
                    button.classList.add('active');
                    const tabId = button.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // Initialize both tools
            initPdfExtractor();
            initWidgetCreator();
        });
        
        // -------------------------------
        // PDF IMAGE EXTRACTOR FUNCTIONALITY
        // -------------------------------
        function initPdfExtractor() {
            // DOM Elements
            const dropzone = document.getElementById('dropzone');
            const fileInput = document.getElementById('file-input');
            const processBtn = document.getElementById('process-btn');
            const clearBtn = document.getElementById('clear-btn');
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const previewContainer = document.getElementById('preview-container');
            const statusElement = document.getElementById('status');
            const logContainer = document.getElementById('log-container');
            const pageInput = document.getElementById('page-input');
            const dpiInput = document.getElementById('dpi-input');
            const resizeInput = document.getElementById('resize-input');
            
            // Uploaded files storage
            let uploadedFiles = [];
            
            // Set up logging
            function logMessage(message, level = 'info') {
                const entry = document.createElement('p');
                entry.className = `log-entry ${level}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logContainer.appendChild(entry);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // Also log to console
                switch(level) {
                    case 'error': console.error(message); break;
                    case 'warn': console.warn(message); break;
                    default: console.log(message);
                }
            }
            
            // Prevent defaults for drag and drop
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            function highlight() {
                dropzone.classList.add('dragover');
            }
            
            function unhighlight() {
                dropzone.classList.remove('dragover');
            }
            
            // Setup drag and drop events
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropzone.addEventListener(eventName, preventDefaults);
                document.body.addEventListener(eventName, preventDefaults);
            });
            
            ['dragenter', 'dragover'].forEach(eventName => {
                dropzone.addEventListener(eventName, highlight);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                dropzone.addEventListener(eventName, unhighlight);
            });
            
            // Handle file selection
            dropzone.addEventListener('click', () => {
                fileInput.click();
            });
            
            // File input change handler
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (files.length === 0) return;
                
                // Filter for PDF files
                const pdfFiles = Array.from(files).filter(file => file.type === 'application/pdf');
                
                if (pdfFiles.length === 0) {
                    showStatus('No PDF files were selected.', 'error');
                    return;
                }
                
                // Store the files and enable the process button
                uploadedFiles = pdfFiles;
                logMessage(`Selected ${uploadedFiles.length} PDF files`);
                processBtn.disabled = false;
                
                // Clear previous results
                previewContainer.innerHTML = '';
                hideStatus();
            });
            
            // Drop handler
            dropzone.addEventListener('drop', (e) => {
                const files = e.dataTransfer.files;
                if (files.length === 0) return;
                
                // Filter for PDF files
                const pdfFiles = Array.from(files).filter(file => file.type === 'application/pdf');
                
                if (pdfFiles.length === 0) {
                    showStatus('No PDF files were selected.', 'error');
                    return;
                }
                
                // Store the files and enable the process button
                uploadedFiles = pdfFiles;
                logMessage(`Selected ${uploadedFiles.length} PDF files`);
                processBtn.disabled = false;
                
                // Clear previous results
                previewContainer.innerHTML = '';
                hideStatus();
            });
            
            // Process button click handler
            processBtn.addEventListener('click', async () => {
                if (uploadedFiles.length === 0) return;
                
                // Parse options
                const dpi = parseInt(dpiInput.value, 10);
                const resizeToA4 = resizeInput.value === 'true';
                
                // Parse page numbers
                let pageNumbers = [];
                if (pageInput.value.trim()) {
                    pageNumbers = pageInput.value.split(',')
                        .map(p => parseInt(p.trim(), 10))
                        .filter(p => !isNaN(p) && p > 0);
                }
                
                const options = {
                    dpi,
                    resizeToA4,
                    pageNumbers: pageNumbers.length > 0 ? pageNumbers : null
                };
                
                logMessage(`Processing ${uploadedFiles.length} files with options: ` + 
                          `DPI=${options.dpi}, Resize=${options.resizeToA4}, Pages=${options.pageNumbers || 'all'}`);
                
                // Disable the button during processing
                processBtn.disabled = true;
                
                // Show progress
                progressContainer.style.display = 'block';
                progressBar.max = uploadedFiles.length;
                progressBar.value = 0;
                progressText.textContent = `Processing 0/${uploadedFiles.length} files...`;
                
                // Clear previous results
                previewContainer.innerHTML = '';
                
                try {
                    let processedCount = 0;
                    
                    for (let i = 0; i < uploadedFiles.length; i++) {
                        const file = uploadedFiles[i];
                        progressText.textContent = `Processing ${i+1}/${uploadedFiles.length}: ${file.name}`;
                        
                        try {
                            logMessage(`Processing ${file.name}`);
                            
                            // Read the file as array buffer
                            const fileData = await readFileAsArrayBuffer(file);
                            
                            // Process the PDF
                            const processedImages = await processPdf(fileData, options);
                            
                            if (processedImages.length > 0) {
                                logMessage(`Successfully processed ${file.name}, ${processedImages.length} pages extracted`);
                                processedCount++;
                                
                                // Display the results
                                processedImages.forEach(({ pageNum, imageData }) => {
                                    displayImage(file.name, pageNum, imageData);
                                });
                                
                                // Add a "Download All" button for multiple pages
                                if (processedImages.length > 1) {
                                    const downloadAllButton = document.createElement('button');
                                    downloadAllButton.textContent = `Download All Pages (${processedImages.length})`;
                                    downloadAllButton.className = 'download-all-button';
                                    
                                    downloadAllButton.addEventListener('click', () => {
                                        try {
                                            logMessage('Preparing to download all images as ZIP...');
                                            
                                            const zip = new JSZip();
                                            
                                            // Add each image to the zip
                                            for (const { pageNum, imageData } of processedImages) {
                                                const filename = `${file.name.replace('.pdf', '')}_page${pageNum}.png`;
                                                zip.file(filename, imageData);
                                            }
                                            
                                            // Generate the zip
                                            zip.generateAsync({ type: 'blob' }).then((zipContent) => {
                                                // Download the zip
                                                const a = document.createElement('a');
                                                a.href = URL.createObjectURL(zipContent);
                                                a.download = `${file.name.replace('.pdf', '')}_all_pages.zip`;
                                                document.body.appendChild(a);
                                                a.click();
                                                document.body.removeChild(a);
                                                
                                                logMessage('All pages downloaded as ZIP');
                                            }).catch(err => {
                                                logMessage(`Error creating ZIP: ${err.message}`, 'error');
                                            });
                                        } catch (err) {
                                            logMessage(`Error creating ZIP: ${err.message}`, 'error');
                                        }
                                    });
                                    
                                    previewContainer.insertAdjacentElement('beforebegin', downloadAllButton);
                                }
                            } else {
                                logMessage(`No images extracted from ${file.name}`, 'warn');
                            }
                        } catch (err) {
                            logMessage(`Error processing ${file.name}: ${err.message}`, 'error');
                        }
                        
                        // Update progress bar
                        progressBar.value = i + 1;
                    }
                    
                    progressText.textContent = `Processed ${processedCount}/${uploadedFiles.length} files`;
                    showStatus(`Successfully processed ${processedCount} out of ${uploadedFiles.length} files`, 'success');
                } catch (err) {
                    logMessage(`Error during processing: ${err.message}`, 'error');
                    showStatus('An error occurred during processing. Check the log for details.', 'error');
                } finally {
                    processBtn.disabled = false;
                }
            });
            
            // Clear fields button
            clearBtn.addEventListener('click', clearFields);
            
            // Function to clear all fields and reset the application
            function clearFields() {
                // Reset uploaded files
                uploadedFiles = [];
                
                // Reset input fields to defaults
                pageInput.value = '1';
                dpiInput.value = '300';
                resizeInput.value = 'true';
                
                // Clear results and status
                previewContainer.innerHTML = '';
                hideStatus();
                
                // Reset log container (keep only the initial message)
                logContainer.innerHTML = '<p class="log-entry info">System ready. Upload PDF files to begin.</p>';
                
                // Disable process button
                processBtn.disabled = true;
                
                // Hide progress container
                progressContainer.style.display = 'none';
                
                // Remove any download all buttons
                const downloadAllButtons = document.querySelectorAll('.download-all-button');
                downloadAllButtons.forEach(button => button.remove());
                
                // Clear the file input value
                fileInput.value = '';
                
                logMessage('All fields cleared. Ready for new files.');
            }
            
            // Display an image in the preview container
            function displayImage(fileName, pageNum, imageData) {
                // Create blob URL from the image data
                const blob = new Blob([imageData], { type: 'image/png' });
                const url = URL.createObjectURL(blob);
                
                // Create preview item
                const item = document.createElement('div');
                item.className = 'preview-item';
                
                // Preview header
                const header = document.createElement('div');
                header.className = 'preview-header';
                
                const title = document.createElement('h3');
                title.className = 'preview-title';
                title.textContent = `${fileName} - Page ${pageNum}`;
                header.appendChild(title);
                
                item.appendChild(header);
                
                // Preview image
                const img = document.createElement('img');
                img.className = 'preview-image';
                img.src = url;
                img.alt = `${fileName} - Page ${pageNum}`;
                item.appendChild(img);
                
                // Preview actions
                const actions = document.createElement('div');
                actions.className = 'preview-actions';
                
                // PNG Download button
                const downloadBtn = document.createElement('button');
                downloadBtn.textContent = 'Download PNG';
                downloadBtn.addEventListener('click', () => {
                    // Create a download link
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${fileName.replace('.pdf', '')}_page${pageNum}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                });
                
                actions.appendChild(downloadBtn);
                item.appendChild(actions);
                
                // Add to preview container
                previewContainer.appendChild(item);
            }
            
            // Helper function to read a File as ArrayBuffer
            function readFileAsArrayBuffer(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(reader.error);
                    reader.readAsArrayBuffer(file);
                });
            }
            
            // Helper functions for status display
            function showStatus(message, type) {
                statusElement.textContent = message;
                statusElement.className = `status ${type}`;
                statusElement.style.display = 'block';
            }
            
            function hideStatus() {
                statusElement.style.display = 'none';
            }
            
            // Process PDF function
            async function processPdf(pdfData, options = {}) {
                const {
                    pageNumbers = null, // null means all pages
                    dpi = 300,
                    resizeToA4 = true
                } = options;
                
                const results = [];
                let pdfDoc = null;
                
                try {
                    // Load the PDF document
                    pdfDoc = await pdfjsLib.getDocument({ data: pdfData }).promise;
                    logMessage(`PDF loaded with ${pdfDoc.numPages} pages`);
                    
                    // Determine which pages to process
                    const pagesToProcess = pageNumbers || Array.from(
                        { length: pdfDoc.numPages }, 
                        (_, i) => i + 1
                    );
                    
                    // A4 dimensions in pixels at specified DPI (210mm × 297mm)
                    const A4_WIDTH_MM = 210;
                    const A4_HEIGHT_MM = 297;
                    const MM_TO_INCHES = 1 / 25.4;
                    const widthInches = A4_WIDTH_MM * MM_TO_INCHES;
                    const heightInches = A4_HEIGHT_MM * MM_TO_INCHES;
                    const widthPx = Math.round(widthInches * dpi);
                    const heightPx = Math.round(heightInches * dpi);
                    
                    // Process requested pages
                    for (const pageNum of pagesToProcess) {
                        if (pageNum < 1 || pageNum > pdfDoc.numPages) {
                            logMessage(`Page ${pageNum} out of range, skipping`, 'warn');
                            continue;
                        }
                        
                        try {
                            // Get the page
                            const page = await pdfDoc.getPage(pageNum);
                            
                            // Calculate scale to match desired DPI
                            // PDF uses 72 DPI as default
                            const scale = dpi / 72;
                            const viewport = page.getViewport({ scale });
                            
                            // Create canvas for rendering
                            const canvas = document.createElement('canvas');
                            canvas.width = viewport.width;
                            canvas.height = viewport.height;
                            const ctx = canvas.getContext('2d');
                            
                            // Render the PDF page to the canvas
                            await page.render({
                                canvasContext: ctx,
                                viewport
                            }).promise;
                            
                            // Get text content
                            const textContent = await page.getTextContent();
                            logMessage(`Found ${textContent.items.length} text items on page ${pageNum}`);
                            
                            // Get the canvas image data
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            
                            // Detect if this is a template with a banner
                            const isTemplate = checkForTemplateBanner(imageData);
                            if (isTemplate) {
                                logMessage(`Detected template document - using specialized text removal`);
                            }
                            
                            // Remove text using the improved method that handles PDF coordinates correctly
                            removeTextUsingPdfData(imageData, textContent, scale, page, viewport);
                            
                            // Put the processed image data back to the canvas
                            ctx.putImageData(imageData, 0, 0);
                            
                            // Resize to A4 if requested
                            let finalCanvas = canvas;
                            if (resizeToA4) {
                                finalCanvas = document.createElement('canvas');
                                finalCanvas.width = widthPx;
                                finalCanvas.height = heightPx;
                                const finalCtx = finalCanvas.getContext('2d');
                                // Use better quality resizing
                                finalCtx.imageSmoothingQuality = 'high';
                                finalCtx.drawImage(canvas, 0, 0, widthPx, heightPx);
                            }
                            
                            // Convert canvas to PNG data
                            const pngData = await new Promise(resolve => {
                                finalCanvas.toBlob(blob => {
                                    const reader = new FileReader();
                                    reader.onloadend = () => resolve(new Uint8Array(reader.result));
                                    reader.readAsArrayBuffer(blob);
                                }, 'image/png');
                            });
                            
                            results.push({
                                pageNum,
                                imageData: pngData
                            });
                            
                            logMessage(`Successfully processed page ${pageNum}`);
                        } catch (err) {
                            logMessage(`Error processing page ${pageNum}: ${err.message}`, 'error');
                        }
                    }
                    
                    return results;
                } catch (err) {
                    logMessage(`Error processing PDF: ${err.message}`, 'error');
                    throw err;
                }
            }
            
            /**
             * Check if the image contains a template banner (like MicroAge)
             * @param {ImageData} imageData - Canvas image data
             * @returns {boolean} - True if a banner is detected
             */
            function checkForTemplateBanner(imageData) {
                const { width, height, data } = imageData;
                
                // Sample the top area of the image to check for red banner
                const redPixelCount = {count: 0, total: 0};
                const sampleHeight = Math.floor(height * 0.15); // Check top 15% of image
                
                // Sample every 10th pixel to save processing
                for (let y = 0; y < sampleHeight; y += 10) {
                    for (let x = 0; x < width; x += 10) {
                        const idx = (y * width + x) * 4;
                        
                        // Count pixels with high red component and low green/blue (red banner)
                        if (data[idx] > 180 && data[idx+1] < 100 && data[idx+2] < 100) {
                            redPixelCount.count++;
                        }
                        
                        redPixelCount.total++;
                    }
                }
                
                // If at least 5% of sampled pixels are red, consider it a banner
                return (redPixelCount.count / redPixelCount.total) > 0.05;
            }
            
            /**
             * Remove text using PDF data coordinates
             * @param {ImageData} imageData - Canvas image data
             * @param {Object} textContent - PDF.js text content
             * @param {number} scale - Scale factor for coordinates
             * @param {Object} page - PDF.js page object
             * @param {Object} viewport - PDF.js viewport
             */
            function removeTextUsingPdfData(imageData, textContent, scale, page, viewport) {
                const { width, height, data } = imageData;
                
                // Protected areas for banners, logos, etc.
                const protectedAreas = [];
                
                // If this is a template with header, protect the top area
                if (checkForTemplateBanner(imageData)) {
                    // Protect the top area (header/banner)
                    const bannerHeight = Math.floor(height * 0.2);
                    protectedAreas.push({
                        x0: 0,
                        y0: 0, 
                        x1: width,
                        y1: bannerHeight
                    });
                    
                    // Also protect the logo area
                    const logoWidth = Math.floor(width * 0.2);
                    const logoHeight = Math.floor(height * 0.35);
                    protectedAreas.push({
                        x0: 0,
                        y0: 0,
                        x1: logoWidth,
                        y1: logoHeight
                    });
                }
                
                // First, create a mask for all text areas
                const textMask = new Uint8Array(width * height);
                
                // Process all text items
                for (const item of textContent.items) {
                    const text = item.str.trim();
                    if (!text) continue;
                    
                    // Get font information
                    const transform = item.transform;
                    const fontSize = Math.abs(transform[3]);
                    
                    // PDF coordinates start from bottom-left with y-axis pointing up
                    // Canvas coordinates start from top-left with y-axis pointing down
                    // Need to flip the y-coordinate
                    const itemX = transform[4] * scale;
                    const itemY = viewport.height - (transform[5] * scale);
                    
                    // Calculate text dimensions with very generous padding
                    // We want to over-estimate rather than under-estimate
                    const extraPadding = Math.max(fontSize * scale, 10);
                    
                    // For special elements like [Titre du document], use even more padding
                    const isSpecialText = text.includes('[') || text.includes(']');
                    const padding = isSpecialText ? extraPadding * 2 : extraPadding;
                    
                    // Calculate text box coordinates
                    let x0 = Math.floor(itemX - padding);
                    let y0 = Math.floor(itemY - fontSize * scale - padding);
                    
                    // Estimate width based on text content
                    const textWidthFactor = isSpecialText ? 1.2 : 0.6; // Special text is usually wider
                    const itemWidth = (item.width || (fontSize * text.length * textWidthFactor)) * scale;
                    const itemHeight = fontSize * scale * 2; // Make it tall enough for descenders
                    
                    let x1 = Math.floor(itemX + itemWidth + padding);
                    let y1 = Math.floor(itemY + padding);
                    
                    // Ensure coordinates are within image bounds
                    x0 = Math.max(0, x0);
                    y0 = Math.max(0, y0);
                    x1 = Math.min(width - 1, x1);
                    y1 = Math.min(height - 1, y1);
                    
                    // Skip invalid areas
                    if (x1 <= x0 || y1 <= y0) continue;
                    
                    // Check if this text is in a protected area
                    let inProtectedArea = false;
                    for (const area of protectedAreas) {
                        // Check for overlap
                        if (!(x1 < area.x0 || x0 > area.x1 || y1 < area.y0 || y0 > area.y1)) {
                            inProtectedArea = true;
                            break;
                        }
                    }
                    
                    // Skip if in protected area
                    if (inProtectedArea) continue;
                    
                    // Mark this area in the text mask
                    for (let y = y0; y < y1; y++) {
                        for (let x = x0; x < x1; x++) {
                            textMask[y * width + x] = 1;
                        }
                    }
                    
                    // Fill with white
                    for (let y = y0; y < y1; y++) {
                        for (let x = x0; x < x1; x++) {
                            const idx = (y * width + x) * 4;
                            data[idx] = 255;     // R
                            data[idx + 1] = 255; // G
                            data[idx + 2] = 255; // B
                        }
                    }
                    
                    // For special text like [Titre du document], add additional rectangle
                    // This helps with text that PDF.js doesn't properly report dimensions for
                    if (isSpecialText) {
                        // Add another rectangle with more padding
                        const morePadding = padding * 2;
                        const centerX = (x0 + x1) / 2;
                        const centerY = (y0 + y1) / 2;
                        const halfWidth = (x1 - x0) / 2 + morePadding;
                        const halfHeight = (y1 - y0) / 2 + morePadding;
                        
                        const sx0 = Math.max(0, Math.floor(centerX - halfWidth));
                        const sy0 = Math.max(0, Math.floor(centerY - halfHeight));
                        const sx1 = Math.min(width - 1, Math.floor(centerX + halfWidth));
                        const sy1 = Math.min(height - 1, Math.floor(centerY + halfHeight));
                        
                        // Skip invalid areas
                        if (sx1 <= sx0 || sy1 <= sy0) continue;
                        
                        // Skip if in protected area
                        let specialInProtectedArea = false;
                        for (const area of protectedAreas) {
                            if (!(sx1 < area.x0 || sx0 > area.x1 || sy1 < area.y0 || sy0 > area.y1)) {
                                specialInProtectedArea = true;
                                break;
                            }
                        }
                        
                        if (!specialInProtectedArea) {
                            // Fill with white
                            for (let y = sy0; y < sy1; y++) {
                                for (let x = sx0; x < sx1; x++) {
                                    const idx = (y * width + x) * 4;
                                    data[idx] = 255;     // R
                                    data[idx + 1] = 255; // G
                                    data[idx + 2] = 255; // B
                                }
                            }
                        }
                    }
                }
                
                // Additional pass for areas with much larger padding
                // This is needed for text that PDF.js doesn't report correctly
                for (const item of textContent.items) {
                    const text = item.str.trim();
                    if (!text) continue;
                    
                    // Only do this for text containing brackets or special characters
                    // These are usually titles, headers, etc. that need special handling
                    if (text.includes('[') || text.includes(']') || 
                        text.includes('Titre') || text.includes('document') ||
                        text.includes('Résumé') || text.includes('Catherine')) {
                        
                        const transform = item.transform;
                        const fontSize = Math.abs(transform[3] * 1.5); // Make it larger
                        
                        // Calculate coordinates with very generous padding
                        const itemX = transform[4] * scale;
                        const itemY = viewport.height - (transform[5] * scale);
                        
                        const hugePadding = fontSize * scale * 2;
                        
                        let x0 = Math.floor(itemX - hugePadding);
                        let y0 = Math.floor(itemY - fontSize * scale - hugePadding);
                        
                        // Make the width much larger for these special elements
                        const itemWidth = fontSize * text.length * 1.5 * scale;
                        const itemHeight = fontSize * scale * 3;
                        
                        let x1 = Math.floor(itemX + itemWidth + hugePadding);
                        let y1 = Math.floor(itemY + itemHeight);
                        
                        // Ensure coordinates are within image bounds
                        x0 = Math.max(0, x0);
                        y0 = Math.max(0, y0);
                        x1 = Math.min(width - 1, x1);
                        y1 = Math.min(height - 1, y1);
                        
                        // Skip invalid areas
                        if (x1 <= x0 || y1 <= y0) continue;
                        
                        // Check if this text is in a protected area
                        let inProtectedArea = false;
                        for (const area of protectedAreas) {
                            if (!(x1 < area.x0 || x0 > area.x1 || y1 < area.y0 || y0 > area.y1)) {
                                inProtectedArea = true;
                                break;
                            }
                        }
                        
                        if (!inProtectedArea) {
                            // Fill with white
                            for (let y = y0; y < y1; y++) {
                                for (let x = x0; x < x1; x++) {
                                    const idx = (y * width + x) * 4;
                                    data[idx] = 255;     // R
                                    data[idx + 1] = 255; // G
                                    data[idx + 2] = 255; // B
                                }
                            }
                        }
                    }
                }
                
                // If this is a template like MicroAge, add targeted removal for known text positions
                if (checkForTemplateBanner(imageData)) {
                    // Target central title area - [Titre du document]
                    const titleY = Math.floor(height * 0.7);
                    const titleHeight = Math.floor(height * 0.1);
                    const titleX = Math.floor(width * 0.3);
                    const titleWidth = Math.floor(width * 0.4);
                    
                    // Fill the title area with white
                    for (let y = titleY; y < titleY + titleHeight; y++) {
                        for (let x = titleX; x < titleX + titleWidth; x++) {
                            const idx = (y * width + x) * 4;
                            data[idx] = 255;     // R
                            data[idx + 1] = 255; // G
                            data[idx + 2] = 255; // B
                        }
                    }
                    
                    // Target subtitle area - [Sous-titre du document]
                    const subtitleY = Math.floor(height * 0.8);
                    const subtitleHeight = Math.floor(height * 0.05);
                    const subtitleX = Math.floor(width * 0.35);
                    const subtitleWidth = Math.floor(width * 0.3);
                    
                    // Fill the subtitle area with white
                    for (let y = subtitleY; y < subtitleY + subtitleHeight; y++) {
                        for (let x = subtitleX; x < subtitleX + subtitleWidth; x++) {
                            const idx = (y * width + x) * 4;
                            data[idx] = 255;     // R
                            data[idx + 1] = 255; // G
                            data[idx + 2] = 255; // B
                        }
                    }
                    
                    // Target Résumé text area
                    const resumeY = Math.floor(height * 0.85);
                    const resumeHeight = Math.floor(height * 0.1);
                    const resumeX = Math.floor(width * 0.1);
                    const resumeWidth = Math.floor(width * 0.8);
                    
                    // Fill the resume area with white
                    for (let y = resumeY; y < resumeY + resumeHeight; y++) {
                        for (let x = resumeX; x < resumeX + resumeWidth; x++) {
                            const idx = (y * width + x) * 4;
                            data[idx] = 255;     // R
                            data[idx + 1] = 255; // G
                            data[idx + 2] = 255; // B
                        }
                    }
                    
                    // Target the author name area
                    const authorY = Math.floor(height * 0.95);
                    const authorHeight = Math.floor(height * 0.04);
                    const authorX = Math.floor(width * 0.5);
                    const authorWidth = Math.floor(width * 0.45);
                    
                    // Fill the author area with white
                    for (let y = authorY; y < authorY + authorHeight; y++) {
                        for (let x = authorX; x < authorX + authorWidth; x++) {
                            const idx = (y * width + x) * 4;
                            data[idx] = 255;     // R
                            data[idx + 1] = 255; // G
                            data[idx + 2] = 255; // B
                        }
                    }
                }
            }
        }
        
        // -------------------------------
        // WIDGET CREATOR FUNCTIONALITY
        // -------------------------------
        function initWidgetCreator() {
            // DOM Elements
            const urlInput = document.getElementById('website-url');
            const fetchBtn = document.getElementById('fetch-btn');
            const imagePositionSelect = document.getElementById('image-position');
            const paragraphCountSelect = document.getElementById('paragraph-count');
            const customImageInput = document.getElementById('custom-image');
            const summaryTextarea = document.getElementById('summary-text');
            const generateWidgetBtn = document.getElementById('generate-widget-btn');
            const clearWidgetBtn = document.getElementById('clear-widget-btn');
            const widgetStatus = document.getElementById('widget-status');
            const widgetPreviewContainer = document.getElementById('widget-preview-container');
            const widgetPreview = document.getElementById('widget-preview');
            const widgetCode = document.getElementById('widget-code');
            const copyCodeBtn = document.getElementById('copy-code-btn');
            
            // State Variables
            let currentImage = null;
            let customImageUrl = null;
            
            // Event Listeners
            fetchBtn.addEventListener('click', fetchWebsiteContent);
            customImageInput.addEventListener('change', handleCustomImage);
            generateWidgetBtn.addEventListener('click', generateWidget);
            clearWidgetBtn.addEventListener('click', clearWidgetForm);
            copyCodeBtn.addEventListener('click', copyWidgetCode);
            
            // Helper function for showing widget status messages
            function showWidgetStatus(message, type) {
                widgetStatus.textContent = message;
                widgetStatus.className = `status ${type}`;
                widgetStatus.style.display = 'block';
                setTimeout(() => {
                    widgetStatus.style.display = 'none';
                }, 5000); // Hide after 5 seconds
            }
            
            // Handle custom image upload
            function handleCustomImage(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                if (!file.type.startsWith('image/')) {
                    showWidgetStatus('Please select a valid image file.', 'error');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    customImageUrl = event.target.result;
                    showWidgetStatus('Custom image uploaded successfully.', 'success');
                };
                reader.readAsDataURL(file);
            }
            
 // Fetch website content
async function fetchWebsiteContent() {
    const url = urlInput.value.trim();
    
    if (!url) {
        showWidgetStatus('Please enter a valid URL.', 'error');
        return;
    }
    
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
        showWidgetStatus('URL must start with http:// or https://.', 'error');
        return;
    }
    
    try {
        // Show loading status
        showWidgetStatus('Fetching website content...', 'info');
        
        // Call the summary function
        const summaryResponse = await fetch('/.netlify/functions/summarize-website', {
            method: 'POST',
            body: JSON.stringify({ url })
        });
        
        // Call the image function
        const imageResponse = await fetch('/.netlify/functions/get-website-images', {
            method: 'POST',
            body: JSON.stringify({ url })
        });
        
        if (!summaryResponse.ok) {
            throw new Error('Error fetching website summary');
        }
        
        if (!imageResponse.ok) {
            throw new Error('Error fetching website images');
        }
        
        const summaryData = await summaryResponse.json();
        const imageData = await imageResponse.json();
        
        // Update UI with the fetched content
        summaryTextarea.value = summaryData.summary || "No summary available";
        currentImage = imageData.mainImage || 'https://via.placeholder.com/400x300/cccccc/666666?text=No+Image';
        
        showWidgetStatus('Content fetched successfully!', 'success');
    } catch (error) {
        console.error('Error fetching website content:', error);
        showWidgetStatus('Error fetching website content. The website might be blocking requests.', 'error');
    }
}
            
            // Generate widget preview and code
            function generateWidget() {
                // Get settings
                const imagePosition = imagePositionSelect.value;
                const paragraphCount = parseInt(paragraphCountSelect.value, 10);
                const summaryText = summaryTextarea.value.trim();
                
                if (!summaryText) {
                    showWidgetStatus('Please fetch or enter content first.', 'error');
                    return;
                }
                
                // Use custom image if uploaded, otherwise use fetched image
                const imageUrl = customImageUrl || currentImage || 'https://via.placeholder.com/400x300/cccccc/666666?text=No+Image';
                
                // Split summary into paragraphs and limit to selected count
                let paragraphs = summaryText.split('\n\n')
                    .filter(p => p.trim())
                    .slice(0, paragraphCount);
                
                // If we don't have enough paragraphs, split the text
                if (paragraphs.length < paragraphCount && summaryText.length > 50) {
                    paragraphs = [];
                    const sentences = summaryText.split('. ');
                    const sentencesPerParagraph = Math.ceil(sentences.length / paragraphCount);
                    
                    for (let i = 0; i < paragraphCount; i++) {
                        const start = i * sentencesPerParagraph;
                        const end = Math.min(start + sentencesPerParagraph, sentences.length);
                        if (start < sentences.length) {
                            const paragraph = sentences.slice(start, end).join('. ');
                            paragraphs.push(paragraph.endsWith('.') ? paragraph : paragraph + '.');
                        }
                    }
                }
                
                // Ensure we have at least one paragraph
                if (paragraphs.length === 0) {
                    paragraphs = [summaryText];
                }
                
                // Create HTML for the widget
                const paragraphsHtml = paragraphs.map(p => `<p>${p}</p>`).join('');
                
                let widgetHtml;
                if (imagePosition === 'left') {
                    widgetHtml = `<table style="width:100%; border-collapse:collapse;">
  <tr>
    <td style="width:30%; vertical-align:top; padding:10px;"><img src="${imageUrl}" alt="Content Image" style="width:100%; height:auto; max-width:300px;"></td>
    <td style="width:70%; vertical-align:top; padding:10px;">${paragraphsHtml}</td>
  </tr>
</table>`;
                } else {
                    widgetHtml = `<table style="width:100%; border-collapse:collapse;">
  <tr>
    <td style="width:70%; vertical-align:top; padding:10px;">${paragraphsHtml}</td>
    <td style="width:30%; vertical-align:top; padding:10px;"><img src="${imageUrl}" alt="Content Image" style="width:100%; height:auto; max-width:300px;"></td>
  </tr>
</table>`;
                }
                
                // Update preview
                widgetPreview.innerHTML = widgetHtml;
                widgetCode.textContent = widgetHtml;
                
                // Show preview section
                widgetPreviewContainer.style.display = 'block';
                
                showWidgetStatus('Widget generated successfully!', 'success');
            }
            
            // Copy widget code to clipboard
            function copyWidgetCode() {
                const tempTextarea = document.createElement('textarea');
                tempTextarea.value = widgetCode.textContent;
                document.body.appendChild(tempTextarea);
                tempTextarea.select();
                document.execCommand('copy');
                document.body.removeChild(tempTextarea);
                
                showWidgetStatus('Widget code copied to clipboard!', 'success');
            }
            
            // Clear widget form
            function clearWidgetForm() {
                urlInput.value = '';
                imagePositionSelect.value = 'left';
                paragraphCountSelect.value = '2';
                customImageInput.value = '';
                summaryTextarea.value = '';
                currentImage = null;
                customImageUrl = null;
                widgetPreviewContainer.style.display = 'none';
                
                showWidgetStatus('Form cleared.', 'info');
            }
        }
    </script>
<!-- Matrix Builder Tab -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    // First add Matrix Builder HTML, CSS, and JavaScript
    
    // Matrix Builder HTML
    const matrixBuilderHTML = `
        <p>Create comparison tables and feature matrices for your products and services.</p>
        
        <div class="container">
            <div class="matrix-form">
                <h3>Table Settings</h3>
                <div class="options">
                    <div class="option-group">
                        <label for="matrix-rows">Number of Rows:</label>
                        <input type="number" id="matrix-rows" min="1" max="20" value="5">
                    </div>
                    
                    <div class="option-group">
                        <label for="matrix-columns">Number of Columns:</label>
                        <input type="number" id="matrix-columns" min="2" max="10" value="4">
                    </div>
                    
                    <div class="option-group">
                        <label for="header-bg-color">Header Background:</label>
                        <input type="color" id="header-bg-color" value="#96b83b">
                    </div>
                    
                    <div class="option-group">
                        <label for="header-text-color">Header Text:</label>
                        <input type="color" id="header-text-color" value="#ffffff">
                    </div>
                    
                    <div class="option-group">
                        <label for="row-bg-color-1">Row Background 1:</label>
                        <input type="color" id="row-bg-color-1" value="#f2f2f2">
                    </div>
                    
                    <div class="option-group">
                        <label for="row-bg-color-2">Row Background 2:</label>
                        <input type="color" id="row-bg-color-2" value="#ffffff">
                    </div>
                </div>
                
                <button id="update-matrix-btn" class="btn btn-primary">Update Matrix</button>
                
                <div id="matrix-editor" class="matrix-editor">
                    <div id="matrix-headers" class="matrix-headers">
                        <!-- Column headers will be generated here -->
                    </div>
                    
                    <div id="matrix-rows-container" class="matrix-rows">
                        <!-- Rows will be generated here -->
                    </div>
                </div>
                
                <div class="button-container">
                    <button id="generate-matrix-btn" class="btn btn-success">Generate Matrix</button>
                    <button id="clear-matrix-btn" class="btn btn-secondary">Clear All</button>
                </div>
            </div>
            
            <div id="matrix-preview-container" style="display: none;">
                <h3>Matrix Preview</h3>
                <div class="matrix-preview" id="matrix-preview"></div>
                
                <div class="code-container">
                    <div class="code-header">
                        <h3>HTML Code</h3>
                        <button id="copy-matrix-code-btn" class="btn btn-primary">Copy Code</button>
                    </div>
                    <div class="code-content" id="matrix-code"></div>
                </div>
            </div>
        </div>
    `;
    
    // Add CSS for Matrix Builder
    const style = document.createElement('style');
    style.textContent = `
        /* Matrix Builder Styles */
        .matrix-editor {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            background-color: white;
        }
        
        .matrix-headers {
            display: grid;
            grid-template-columns: 300px repeat(9, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .matrix-rows {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .matrix-row {
            display: grid;
            grid-template-columns: 300px repeat(9, 1fr);
            gap: 10px;
            align-items: center;
        }
        
        .cell-type-select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
    `;
    document.head.appendChild(style);
    // Now create and add the tab elements
    
// 1. Create the Matrix Builder tab button
const tabsContainer = document.querySelector('.tabs');
if (tabsContainer) {
    // Look for "Additional Tool" or "future" tab
    const tabButtons = document.querySelectorAll('.tab-button');
    let futureTabFound = false;
    
    for (const btn of tabButtons) {
        const dataTab = btn.getAttribute('data-tab');
        if (dataTab === 'future' || btn.textContent.includes('Additional')) {
            // Replace this button with our Matrix Builder button
            btn.setAttribute('data-tab', 'matrix');
            btn.textContent = 'Matrix Builder';
            futureTabFound = true;
            console.log('Replaced existing tab button with Matrix Builder');
            break;
        }
    }
    
    // If no future tab found, add a new tab button
    if (!futureTabFound) {
        const newButton = document.createElement('button');
        newButton.className = 'tab-button';
        newButton.setAttribute('data-tab', 'matrix');
        newButton.textContent = 'Matrix Builder';
        tabsContainer.appendChild(newButton);
        console.log('Added new Matrix Builder tab button');
    }
    
    // Add proper tab switching for all tab buttons
    const allTabButtons = document.querySelectorAll('.tab-button');
    allTabButtons.forEach(button => {
        button.addEventListener('click', function() {
            // Remove active class from all buttons and contents
            allTabButtons.forEach(btn => btn.classList.remove('active'));
            const allTabContents = document.querySelectorAll('.tab-content');
            allTabContents.forEach(content => content.classList.remove('active'));
            
            // Add active class to this button
            this.classList.add('active');
            
            // Add active class to corresponding content
            const tabId = this.getAttribute('data-tab');
            const tabContent = document.getElementById(tabId);
            if (tabContent) {
                tabContent.classList.add('active');
                console.log(`Switched to tab: ${tabId}`);
            } else {
                console.error(`Tab content not found for: ${tabId}`);
            }
        });
    });
}
    // 2. Create the Matrix Builder tab content
    const futureTab = document.getElementById('future');
    if (futureTab) {
        // Replace future tab content with Matrix Builder
        futureTab.id = 'matrix';
        futureTab.innerHTML = matrixBuilderHTML;
        console.log('Replaced future tab content with Matrix Builder');
    } else {
        // Create new tab content
        const matrixTab = document.createElement('div');
        matrixTab.id = 'matrix';
        matrixTab.className = 'tab-content';
        matrixTab.innerHTML = matrixBuilderHTML;
        
        // Find where to insert it - after the last tab content
        const tabContents = document.querySelectorAll('.tab-content');
        if (tabContents.length > 0) {
            const lastTab = tabContents[tabContents.length - 1];
            lastTab.parentNode.insertBefore(matrixTab, lastTab.nextSibling);
        } else {
            // Fallback - append to body
            document.body.appendChild(matrixTab);
        }
        console.log('Created new Matrix Builder tab content');
    }
    
    // Initialize Matrix Builder functionality
    initMatrixBuilder();
    
    // Matrix Builder Functionality
    function initMatrixBuilder() {
        console.log('Initializing Matrix Builder...');
        
        // DOM Elements
        const matrixRows = document.getElementById('matrix-rows');
        const matrixColumns = document.getElementById('matrix-columns');
        const headerBgColor = document.getElementById('header-bg-color');
        const headerTextColor = document.getElementById('header-text-color');
        const rowBgColor1 = document.getElementById('row-bg-color-1');
        const rowBgColor2 = document.getElementById('row-bg-color-2');
        const updateMatrixBtn = document.getElementById('update-matrix-btn');
        const generateMatrixBtn = document.getElementById('generate-matrix-btn');
        const clearMatrixBtn = document.getElementById('clear-matrix-btn');
        const matrixHeaders = document.getElementById('matrix-headers');
        const matrixRowsContainer = document.getElementById('matrix-rows-container');
        const matrixPreviewContainer = document.getElementById('matrix-preview-container');
        const matrixPreview = document.getElementById('matrix-preview');
        const matrixCode = document.getElementById('matrix-code');
        const copyMatrixCodeBtn = document.getElementById('copy-matrix-code-btn');
        
        // Cell content options
        const cellOptions = [
            { value: 'check', label: 'Checkmark' },
            { value: 'text', label: 'Text' },
            { value: 'optional', label: 'Optional' },
            { value: 'empty', label: 'Empty' }
        ];
        
        if (!matrixRows || !matrixHeaders) {
            console.error('Matrix Builder elements not found. DOM structure issue.');
            return;
        }
        
        // Initialize the matrix editor
        updateMatrixEditor();
        
        // Event Listeners
        updateMatrixBtn.addEventListener('click', updateMatrixEditor);
        generateMatrixBtn.addEventListener('click', generateMatrix);
        clearMatrixBtn.addEventListener('click', clearMatrix);
        copyMatrixCodeBtn.addEventListener('click', copyMatrixCode);
        
        // Update the matrix editor based on rows and columns
        function updateMatrixEditor() {
            const rows = parseInt(matrixRows.value) || 5;
            const columns = parseInt(matrixColumns.value) || 4;
            
            // Update headers
            updateHeaders(columns);
            
            // Update rows
            updateMatrixRows(rows, columns);
            
            console.log(`Matrix updated: ${rows} rows, ${columns} columns`);
        }
        
        // Update the column headers
        function updateHeaders(columns) {
            matrixHeaders.innerHTML = '';
            
            // Add the feature column header
            const featureHeader = document.createElement('div');
            featureHeader.className = 'header-cell';
            
            const featureInput = document.createElement('input');
            featureInput.type = 'text';
            featureInput.value = 'Feature/Service';
            featureInput.placeholder = 'Features';
            featureInput.style.cssText = 'width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;';
            featureHeader.appendChild(featureInput);
            
            matrixHeaders.appendChild(featureHeader);
            
            // Add the column headers
            for (let i = 0; i < columns; i++) {
                const headerCell = document.createElement('div');
                headerCell.className = 'header-cell';
                
                const headerInput = document.createElement('input');
                headerInput.type = 'text';
                headerInput.value = i === 0 ? 'Basic' : i === 1 ? 'Standard' : i === 2 ? 'Premium' : `Plan ${i+1}`;
                headerInput.placeholder = `Column ${i+1}`;
                headerInput.style.cssText = 'width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;';
                headerCell.appendChild(headerInput);
                
                matrixHeaders.appendChild(headerCell);
            }
        }
        
        // Update the matrix rows
        function updateMatrixRows(rows, columns) {
            matrixRowsContainer.innerHTML = '';
            
            for (let i = 0; i < rows; i++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'matrix-row';
                
                // Feature name cell
                const featureCell = document.createElement('div');
                featureCell.className = 'feature-name';
                
                const featureInput = document.createElement('input');
                featureInput.type = 'text';
                featureInput.placeholder = `Feature ${i+1}`;
                featureInput.value = '';
                featureInput.style.cssText = 'width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;';
                featureCell.appendChild(featureInput);
                
                rowDiv.appendChild(featureCell);
                
                // Add cells for each column
                for (let j = 0; j < columns; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell-content';
                    
                    const select = document.createElement('select');
                    select.className = 'cell-type-select';
                    
                    // Add options to the select
                    cellOptions.forEach(option => {
                        const optionEl = document.createElement('option');
                        optionEl.value = option.value;
                        optionEl.textContent = option.label;
                        // Default to checkmark for the first two columns
                        if (option.value === 'check' && j <= 1) {
                            optionEl.selected = true;
                        }
                        // Default to empty for others
                        if (option.value === 'empty' && j > 1) {
                            optionEl.selected = true;
                        }
                        select.appendChild(optionEl);
                    });
                    
                    cell.appendChild(select);
                    rowDiv.appendChild(cell);
                }
                
                matrixRowsContainer.appendChild(rowDiv);
            }
        }
        
        // Generate the matrix preview and HTML code
        function generateMatrix() {
            // Get all the current values
            const rows = parseInt(matrixRows.value) || 5;
            const columns = parseInt(matrixColumns.value) || 4;
            const headerBg = headerBgColor.value;
            const headerText = headerTextColor.value;
            const rowBg1 = rowBgColor1.value;
            const rowBg2 = rowBgColor2.value;
            
            // Get column headers
            const headerInputs = matrixHeaders.querySelectorAll('input');
            const headers = Array.from(headerInputs).map(input => input.value.trim() || input.placeholder);
            
            // Get row data
            const rowDivs = matrixRowsContainer.querySelectorAll('.matrix-row');
            const rowData = Array.from(rowDivs).map(row => {
                const featureInput = row.querySelector('input');
                const selects = row.querySelectorAll('select');
                
                return {
                    feature: featureInput.value.trim() || featureInput.placeholder,
                    cells: Array.from(selects).map(select => select.value)
                };
            });
            
            // Generate HTML table
            let tableHtml = `<table style="width:100%; border-collapse:collapse;">\n`;
            
            // Table header
            tableHtml += `  <tr>\n`;
            headers.forEach((header, index) => {
                tableHtml += `    <th style="padding:12px; text-align:${index === 0 ? 'left' : 'center'}; background-color:${headerBg}; color:${headerText};">${header}</th>\n`;
            });
            tableHtml += `  </tr>\n`;
            
            // Table rows
            rowData.forEach((row, rowIndex) => {
                const rowColor = rowIndex % 2 === 0 ? rowBg1 : rowBg2;
                
                tableHtml += `  <tr>\n`;
                tableHtml += `    <td style="padding:12px; text-align:left; background-color:${rowColor};">${row.feature}</td>\n`;
                
                row.cells.forEach(cell => {
                    let cellContent = '';
                    
                    switch(cell) {
                        case 'check':
                            cellContent = `<div style="display:inline-block; width:24px; height:24px; background-color:#8bc34a; border-radius:50%; text-align:center; line-height:24px; color:white;">✓</div>`;
                            break;
                        case 'text':
                            cellContent = 'Yes';
                            break;
                        case 'optional':
                            cellContent = 'Optional';
                            break;
                        case 'empty':
                        default:
                            cellContent = '';
                            break;
                    }
                    
                    tableHtml += `    <td style="padding:12px; text-align:center; background-color:${rowColor};">${cellContent}</td>\n`;
                });
                
                tableHtml += `  </tr>\n`;
            });
            
            tableHtml += `</table>`;
            
            // Update the preview
            matrixPreview.innerHTML = tableHtml;
            
            // Update the code
            matrixCode.textContent = tableHtml;
            
            // Show the preview container
            matrixPreviewContainer.style.display = 'block';
            
            console.log('Matrix generated successfully');
        }
        
        // Clear the matrix editor
        function clearMatrix() {
            matrixRows.value = '5';
            matrixColumns.value = '4';
            headerBgColor.value = '#96b83b';
            headerTextColor.value = '#ffffff';
            rowBgColor1.value = '#f2f2f2';
            rowBgColor2.value = '#ffffff';
            
            updateMatrixEditor();
            matrixPreviewContainer.style.display = 'none';
            
            console.log('Matrix cleared');
        }
        
        // Copy the matrix HTML code
        function copyMatrixCode() {
            const codeText = matrixCode.textContent;
            
            navigator.clipboard.writeText(codeText)
                .then(() => {
                    // Show success message
                    copyMatrixCodeBtn.textContent = 'Copied!';
                    setTimeout(() => {
                        copyMatrixCodeBtn.textContent = 'Copy Code';
                    }, 2000);
                    
                    console.log('Matrix code copied to clipboard');
                })
                .catch(err => {
                    console.error('Failed to copy: ', err);
                    
                    // Fallback copy method
                    const textarea = document.createElement('textarea');
                    textarea.value = codeText;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    
                    copyMatrixCodeBtn.textContent = 'Copied!';
                    setTimeout(() => {
                        copyMatrixCodeBtn.textContent = 'Copy Code';
                    }, 2000);
                });
        }
    }
});
</script>
</body>
</html>
